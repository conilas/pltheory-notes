I've said it before and I'll say it again, as many times as necessary: the world of *compsci* is filled with holes. You look at one definition that you find interesting, dig deeper and find out that the term is ill-defined. You search in books, read the 60's papers and see that people do not use the same definition for the same term. Then it hits you - so how in the name of the holy Unicorn will I talk about this concept when not even the academia shows consensus on it? 

Well, this article is about another ill-defined term, and it probably wont clear your mind. Yet again. But I hope it gets you where I am and that we can at least share this doubt. Let's talk *homoiconicity*.

## Some actual definition

Code as data, same representations of code and data, etc

## Historically speaking

Started with TRAC in the sixties, then talk about Lisp and how HeCoinedTheTerm (talk about how Kay spoke about the term).

## Meta-circular evaluator & macros

## Well, this is unfortunate...

Show the C2 Wiki articles (all them) and show why is it hard. Also show http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.453.7185&rep=rep1&type=pdf because I really liked it.

http://wiki.c2.com/?HomoiconicExampleInManyProgrammingLanguages
http://wiki.c2.com/?HomoiconicExampleInJava
http://wiki.c2.com/?HomoiconicLanguages
http://wiki.c2.com/?HomoiconicFaq

## Some examples

Show the IO example, show the Lisp example, show the TCL example and try to find some 

## Some not-so-much-examples

Show the string + eval idea and explain why it does show some weak typing of homoiconicity because it is not treating it as first class, just some random string representation

(
## Yet again we come to this point

If we talk about weak/strong homoiconic languages, show that we came to yet another ill definition, hopping from one hole to the other.
)

## References
